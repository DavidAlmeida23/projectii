\subsubsection{EL Scripts}

After designing the reference architecture for the Code Cache and refactoring the code according to it, the reference architecture was integrated with the Elaboration Language Tool. This is the EL file for the Code Cache:

\begin{lstlisting}[caption={Code Cache EL file}, label={lst:CCacheEL},language=EL]
import "Interfaces.el"
import "Languages.el"

component CodeCache(C)
{
properties:
int CCache_Size : 32768							// 32*1014
string SourceCode_Location : "0x60040000"		// Hexadecimal
services:
i_CCache s_CCache
references:
i_ISA r_ISA
}
\end{lstlisting}

In the CodeCache.el file \ref{lst:CCacheEL} it's possible to see the definition of the component. Defining all its properties:
\begin{itemize}
	\item 	CCache\_Size - size of the code cache memory with a default value of 32768;
	\item	SourceCode\_Location - location of the source code to be translated with a default value of 0x60040000.
\end{itemize}
And interfaces:
\begin{itemize}
	\item 	s\_CCache - service provided by the CodeCache. This service's type is i\_CCache, which, according to the interfaces.el \ref{lst:CCacheInterfaces} file, contains two functions, a fetch function that receives an address and returns the word contained in that address, and a load function that is responsible for the loading the source code;
	\item	r\_ISA - reference to the source architecture to define the CodeCache word size.
\end{itemize}

\begin{lstlisting}[caption={Code Cache Interfaces EL file}, label={lst:CCacheInterfaces},language=EL]
interface i_ISA {
getWordSize
PCSize
nBitsOpcode
}

interface i_CCache {
fetch
load
}
\end{lstlisting}






\subsubsection{Annotated Source Files}
After writting the EL file it's necessary to annotate the source files, so that the tool can generate the final files accordingly to the users will. 
\begin{lstlisting}[caption={Annotations for CBuffer.cpp}, label={lst:annotCBuffer.cpp},language=C++]
#include "CBuffer.h"

#define CCacheSize @@CodeCache_CSize@@
#define SourceCodeLocation @@CodeCache_SourceCodeLocation@@

//(...)

baseBufferAddr = (@@CodeCache_WordSize@@*)SourceCodeLocation;

\end{lstlisting}

\begin{lstlisting}[caption={Annotations for CBuffer.h}, label={lst:annotCBuffer.h},language=C++]
#ifndef CBUFFER_H
#define CBUFFER_H

class CBuffer
{
public:	
int c_size;       // size of the CBuffer (in bytes)
@@CodeCache_WordSize@@* baseBufferAddr;   // first PC in Cbuffer
@@CodeCache_WordSize@@* lastBufferAddr;   // last PC in Cbuffer

//(...)
\#endif
\end{lstlisting}

Above we can see the annotated files. We can see two files: CBuffer.cpp and CBuffer.h. This files have the annotations that the elaborator will use to generate the final files. The protocol used for the annotation name is @@ComponentName\_Property/Reference@@, and in the CodeCache sources it's possible to see three annotations:
\begin{itemize}
	\item @@CodeCache\_CSize@@ - property that defines the CodeCache size;
	\item @@CodeCache\_SourceCodeLocation@@ - property that defines the CodeCache size;
	\item @@CodeCache\_WordSize@@ - reference to SourceArchitecture that defines the word size.	
\end{itemize}





			
\subsubsection{Configuration Files}
When the EL file is compiled a xml configuration file is generated for each component. This is the xml file generated for the CodeCache.
\begin{lstlisting}[caption={Code Cache xml file}, label={lst:codecachexml},language=xml]
<?xml version="1.0" encoding="UTF-8"?>
<component type="CodeCache">
<elaboration default="SpecificCodeCacheElaboratorTemplate">SpecificCodeCacheElaborator</elaboration>
<properties>
<property type="int" name="CCache_Size" default="32768">
<value>
<element></element>
</value>
</property>
<property type="string" name="SourceCode_Location" default="0x60040000">
<value>
<element></element>
</value>
</property>
</properties>
</component>
\end{lstlisting}

In this file the user can change the properties values. This values are set to the default value inserted in the EL file by default. It's in this file that the user can also configure the name of the elaboration file that he implemented, or leave the default elaborator template that is generated by the tool.



				
\subsubsection{Elaborations}
When all source files are annotated and the all configurations are set it's necessary to implement an elaboration to change the source files and generate the final files.
\begin{lstlisting}[caption={Code Cache Elaboration}, label={lst:CCacheElab},language=java]
public class SpecificCodeCacheElaborator extends AbstractCodeCacheElaborator 
{	
SpecificConfigReader scr = null;

public void generate(){
System.out.println("This is the CodeCache template specific elaboration.");

openAnnotatedSource("CBuffer.cpp");		
AbstractSourceArchElaborator SourceArchElab = (AbstractSourceArchElaborator) getElaborator((_SourceArch) target.get_r_ISA());
replaceAnotation("CodeCache_WordSize", (String) SourceArchElab.getI_ISAElaboratorGetWordSize());
replaceAnotation("CodeCache_CSize", target.get_CCache_Size());
replaceAnotation("CodeCache_SourceCodeLocation", target.get_SourceCode_Location());

openAnnotatedSource("CBuffer.h");	
replaceAnotation("CodeCache_WordSize", (String) SourceArchElab.getI_ISAElaboratorGetWordSize());
}	
public Object getI_CCacheElaboratorFetch(){
return "FETCH";
}	
public Object getI_CCacheElaboratorLoad(){
return "load";
}	
public ArrayList<String> getI_CCacheElaboratorHeaderlist(){
ArrayList<String> list = new ArrayList<String>();
return list;
}	
}
\end{lstlisting}
This is the elaboration implemented to change the source files annotations. It's necessary to change annotations in two sources. The Cbuffer.h file only has one annotation to replace: CodeCache\_WordSize. This annotation is replaced by one of the functions contained in the service provided by the Source Architecture named ISA.
The Cbuffer.cpp file has three annotations to replace. The first annotation is the same as in the other file, and needs to be replaced by the same service. The other annotations are CodeCache\_CSize and CodeCache\_SourceCodeLocation, that need to be replaced by the corresponding properties of the CodeCache.
The elaboration also contains a get method for all the services that the code cache implements, and this methods return the name of the function that implements them.

